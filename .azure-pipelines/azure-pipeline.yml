parameters:
- name: BuildConfiguration
  displayName: Select BuildConfiguration
  type: string
  default: release
  values:
  - release
  - debug

trigger:
  branches:
    include:
    - master
    - hotfix
    - feature
  paths:
    include:
    - .azure-pipelines
    - MyPkgLib
    - MyPkgLib.Tests
    exclude:
    - README.md

variables:
- group: nuget-public
- name: BuildConfiguration
  value: ${{ parameters.BuildConfiguration }}
- name: ProjectName
  value: MyPkgLib

pool:
  vmImage: windows-latest #because we have a .NET 4.7.2 target

jobs:
- job: build
  steps:
  # - task: NuGetCommand@2
  #   inputs:
  #     command: custom
  #     arguments: install GitVersion.CommandLine -Version 4.0.0 -OutputDirectory $(Build.BinariesDirectory)/tools -ExcludeVersion
  
  # - script: mono $(Build.BinariesDirectory)/tools/GitVersion.CommandLine/tools/GitVersion.exe /output buildserver /nofetch

  #- pwsh: dotnet tool update -g GitVersion.Tool
  - pwsh: gitversion /output buildserver /nofetch
    displayName: gitversion

  - pwsh: Write-Host "##vso[Build.UpdateBuildNumber]$(GitVersion.NuGetVersion)"
    displayName: UpdateBuildNumber

  - task: UseDotNet@2
    displayName: .NET Core 3.1.x SDK
    inputs:
      version: 3.1.x
  
  - task: UseDotNet@2
    displayName: .NET 5.x SDK
    inputs:
      version: 5.x
      includePreviewVersions: true

  - pwsh: dotnet --list-sdks
    displayName: dotnet --list-sdks

  #note: this dotnet restore step is actually unnecessary as dotnet build does a restore by default, left for clarity
  #todo: cache the output of this for faster build speed?
  # - task: DotNetCoreCLI@2
  #   displayName: dotnet restore script
  #   inputs:
  #     command: restore
  #     projects: |
  #       **/$(ProjectName).csproj
  #       **/$(ProjectName).Tests.csproj
  - pwsh: dotnet restore
    displayName: dotnet restore
  
  # - task: DotNetCoreCLI@2
  #   displayName: dotnet build
  #   inputs:
  #     command: build
  #     projects: |
  #       **/$(ProjectName).csproj
  #       **/$(ProjectName).Tests.csproj
  #     #note: when using TargetFrameworks the build output merges all output files together
  #     #arguments: --configuration $(BuildConfiguration) --verbosity minimal --output $(Build.ArtifactStagingDirectory)
  #     arguments: --configuration $(BuildConfiguration) --verbosity minimal
  - pwsh: dotnet build --nologo -c $(BuildConfiguration) --verbosity minimal -p:Version='$(GitVersion.NuGetVersion)'
    displayName: dotnet build

  #- publish: $(Build.ArtifactStagingDirectory)
#  - publish: $(System.DefaultWorkingDirectory)/$(ProjectName)/bin

# - job: test
#   dependsOn: build
#   steps:
#   - checkout: none
#   - download: build
  #- task: DownloadPipelineArtifact@2
  #  inputs:
  #    artifact: drop

  # - task: DotNetCoreCLI@2
  #   displayName: dotnet test + calculate code coverage via coverlet
  #   inputs:
  #     command: test
  #     projects: '**/*.Tests/*.csproj'
  #     arguments: --configuration $(BuildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

  - pwsh: dotnet test --nologo -c $(BuildConfiguration) --no-build -p:CollectCoverage=true -p:CoverletOutputFormat=cobertura
    displayName: dotnet test


  #below script is *almost* the same as the DotNetCoreCLI dotnet test above - however doesn't allow wildcard matching AND the test results don't display??
  #- script: dotnet test $(Build.SourcesDirectory)\MyPkgLib.Tests\MyPkgLib.Tests.csproj --logger trx --results-directory $(Agent.TempDirectory) --configuration $(BuildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura
  #  displayName: dotnet test + calculate code coverage via coverlet

  # - script: dir *.cobertura.xml /S /B
  #   displayName: DEBUG search for coverlet files

  # Generate the report using ReportGenerator (https://github.com/danielpalme/ReportGenerator)
  # First install the tool on the machine, then run it
  - script: |
      dotnet tool install -g dotnet-reportgenerator-globaltool
      reportgenerator -reports:$(Build.SourcesDirectory)/src/*.Tests/coverage.cobertura.xml -targetdir:$(Build.SourcesDirectory)/CodeCoverage -reporttypes:HtmlInline_AzurePipelines;Cobertura
    displayName: reportgenerator

  # Publish the code coverage result (summary and web site)
  # The summary allows to view the coverage percentage in the summary tab
  # The web site allows to view which lines are covered directly in Azure Pipeline
  - task: PublishCodeCoverageResults@1
    #displayName: Publish code coverage
    inputs:
      codeCoverageTool: Cobertura
      summaryFileLocation: $(Build.SourcesDirectory)/src/CodeCoverage/Cobertura.xml
      reportDirectory: $(Build.SourcesDirectory)/src/CodeCoverage/

# - job: publish #todo: should this be a deployment job?
#   dependsOn: test
#   variables:
#   - group: nuget-public
#   - name: Version.Major
#     value: 1
#   - name: Version.Minor
#     value: 2
#   - name: Version.PackageMajorMinor
#     value: $(Version.Minor).$(Version.Major)-$(ProjectName)
#   - name: Version.Revision
#     value: $[counter(variables['Version.PackageMajorMinor'], 0)]
#   - name: PackageVersion
#     value: $(Version.Major).$(Version.Minor).$(Version.Revision)
#   steps:
#   #todo: update csproj with the latest PackageVersion
#   - pwsh: Write-Host "123"
#     condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    

  # - task: DotNetCoreCLI@2
  #   displayName: dotnet pack
  #   inputs:
  #     command: pack
  #     configuration: $(BuildConfiguration)
  #     packagesToPack: '**/$(ProjectName).csproj' # Required when command == pack
  #     #packDirectory: $(Build.ArtifactStagingDirectory)   #this should be the Pipeline download directory but didn't figure out how to skip the second build yet
  #     versioningScheme: byEnvVar      # Options: off, byPrereleaseNumber, byEnvVar, byBuildNumber
  #     versionEnvVar: PackageVersion   # Required when versioningScheme == byEnvVar
  #     verbosityPack: normal
  #     #buildProperties: 'SymbolPackageFormat=snupkg'    #not needed because elements added to csproj
  - pwsh: dotnet pack --nologo -c $(BuildConfiguration) --no-build --include-symbols -p:Version='$(GitVersion.NuGetVersion)'
    displayName: dotnet pack

  # - script: echo Version.PackageMajorMinor=$(Version.PackageMajorMinor)
  #   displayName: DEBUG PackageMajorMinor


  # - task: NuGetToolInstaller@0
  #   inputs:
  #     versionSpec: 5.0.2
  #     #checkLatest: false # Optional

  - pwsh: dotnet nuget push $(Build.ArtifactStagingDirectory)/**/*.nupkg --skip-duplicate -s https://api.nuget.org/v3/index.json --api-key $(f2calvNuGet)
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    displayName: dotnet nuget push (public)

  - pwsh: dotnet nuget push $(Build.ArtifactStagingDirectory)/**/*.nupkg --skip-duplicate -s https://apiint.nugettest.org/v3/index.json --api-key $(f2calvNuGetInt)
    condition: and(succeeded(), ne(variables['Build.SourceBranch'], 'refs/heads/master'))
    displayName: dotnet nuget push (preview)